# Yandex_cup_Analytics_2022
## Задачи пробного тура чемпионата по программированию  трека «Аналитика»
### A. Рассчитать pFound
[Условия задачи](https://yandex.ru/cup/analytics/analysis/)

Алгоритм решения:
Считываем файлы в датафреймы. Из датафрейма df_qid_query перебираем текст запроса. В датафрейме df_qid_query получаем id текста запроса. 
Далее, из датафрейма df_qid_url выделяем основной рабочий датафрейм df с одинаковым id запроса. 
К этому датафрейму добавляем значение id host из датафрейма df_hostid_url. 
В цикле перебираем первые 10 уникальных значений id host, отсортированных по убыванию по значению релевантности. 
Если id host содержит несколько документов, выбираем наибольший по значению релевантности и записываем в список. 
По полученному списку релевантных вычисляем pFound. Если текущее значение pFound максимальное, записываем pFound и текст запроса в переменные для вывода.


Вывод для *open_task*:
```
Лучший текст запроса - "гугл переводчик", с максимальным значением метрики pFound: 0.9008362816361585
```
### B. Спортивный турнир
[Условия задачи](https://yandex.ru/cup/analytics/analysis/)

Алгоритм решения:

Считываем количество игр и фамилии в список. Так как нам известно, что первым в файле идет количество игр, 
с помощью pop() извлекаем число (теперь у нас в списке только фамилии) и получаем количество раундов. 
В оригинальном решении сделано изящней, через bit_length(), я же задействовал библиотеку math.
Далее, циклом создаем словарь, где <key>:'Фамилия', <value>:'Количество сыгранных игр игроком'.
Циклом по количеству раундов, перебираем и проверяем, сколько игроков участвовало в каждом раунде. 
То есть, если игрок сыграл две игры, значит он участвовал в первом и втором раунде, в третьем его не может быть. 
Количество находим по <value>. Если во всех раундах количество участников совпадает с количеством раундов, возвращаем <key> последнего раунда.

### C(A from contest). Театральный сезон и телефоны
[Условия задачи](https://contest.yandex.ru/contest/18462/problems/C/)

Алгоритм решения:
Для начала отформатируем все номера, например, отсавим только цифры в строчках.
Посчитаем для каждого названия количество всех номеров и в отсортированном списке первый будет с наибольшим числом телефонных номеров.
Наконец посчитаем количество уникальных номеров для нашего имени с наибольшим числом телефонных номеров.

Вывод для *oticket_logs.csv:
```
Количество уникальных номеров = 181.
```








